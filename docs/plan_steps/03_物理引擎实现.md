# 步骤3：物理引擎实现

## 目标
实现完整的台球物理引擎，包括碰撞检测、速度衰减、旋转系统。

**预计时间**: 4-5天
**优先级**: P0（必须完成）

---

## 一、创建物理引擎核心

### 1.1 创建 PhysicsEngine.swift

**位置**: `Core/Physics/PhysicsEngine.swift`

**代码**:
```swift
import SceneKit

class PhysicsEngine: NSObject {
    weak var scene: BilliardScene?

    // 物理常数
    private let gravity: Float = 9.8
    private let tableFriction: Float = 0.2
    private let airResistance: Float = 0.01
    private let rollingResistance: Float = 0.01

    // 碰撞处理器
    private var collisionHandler: CollisionHandler!

    init(scene: BilliardScene) {
        self.scene = scene
        super.init()

        setupPhysicsWorld()
        collisionHandler = CollisionHandler(engine: self)
    }

    private func setupPhysicsWorld() {
        guard let scene = scene else { return }

        // 配置物理世界
        scene.physicsWorld.gravity = SCNVector3(x: 0, y: -gravity, z: 0)
        scene.physicsWorld.speed = 1.0
        scene.physicsWorld.timeStep = 1.0 / 60.0

        // 设置碰撞代理
        scene.physicsWorld.contactDelegate = collisionHandler
    }

    // MARK: - Update Loop

    func update(deltaTime: TimeInterval) {
        guard let scene = scene else { return }

        // 更新主球
        updateBall(scene.cueBall, deltaTime: deltaTime)

        // 更新所有目标球
        for ball in scene.targetBalls {
            updateBall(ball, deltaTime: deltaTime)
        }

        // 检查球是否进袋
        checkPockets()
    }

    private func updateBall(_ ball: BallNode, deltaTime: TimeInterval) {
        guard let physicsBody = ball.physicsBody else { return }

        // 应用摩擦力
        applyFriction(to: ball, deltaTime: deltaTime)

        // 应用空气阻力
        applyAirResistance(to: ball, deltaTime: deltaTime)

        // 检查是否停止
        checkIfStopped(ball)
    }

    // MARK: - Friction

    private func applyFriction(to ball: BallNode, deltaTime: TimeInterval) {
        guard let physicsBody = ball.physicsBody else { return }

        let velocity = physicsBody.velocity
        let speed = sqrt(velocity.x * velocity.x + velocity.z * velocity.z)

        if speed > 0.01 {
            // 计算摩擦力
            let frictionForce = tableFriction * Float(physicsBody.mass) * gravity

            // 计算减速
            let deceleration = frictionForce / Float(physicsBody.mass)
            let velocityChange = deceleration * Float(deltaTime)

            // 应用减速
            let direction = SCNVector3(
                x: -velocity.x / speed,
                y: 0,
                z: -velocity.z / speed
            )

            let newVelocity = SCNVector3(
                x: velocity.x + direction.x * velocityChange,
                y: velocity.y,
                z: velocity.z + direction.z * velocityChange
            )

            physicsBody.velocity = newVelocity
        }
    }

    private func applyAirResistance(to ball: BallNode, deltaTime: TimeInterval) {
        guard let physicsBody = ball.physicsBody else { return }

        let velocity = physicsBody.velocity
        let speed = sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z)

        if speed > 0.01 {
            let resistance = airResistance * speed * speed
            let direction = SCNVector3(
                x: -velocity.x / speed,
                y: -velocity.y / speed,
                z: -velocity.z / speed
            )

            let force = SCNVector3(
                x: direction.x * resistance,
                y: direction.y * resistance,
                z: direction.z * resistance
            )

            physicsBody.applyForce(force, asImpulse: false)
        }
    }

    private func checkIfStopped(_ ball: BallNode) {
        guard let physicsBody = ball.physicsBody else { return }

        let velocity = physicsBody.velocity
        let speed = sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z)

        if speed < 0.01 {
            ball.stop()
        }
    }

    // MARK: - Pockets

    private func checkPockets() {
        guard let scene = scene else { return }

        // 检查所有球是否进袋
        var ballsToRemove: [BallNode] = []

        for ball in scene.targetBalls {
            if isBallInPocket(ball) {
                ballsToRemove.append(ball)
            }
        }

        // 移除进袋的球
        for ball in ballsToRemove {
            handleBallPocketed(ball)
        }

        // 检查主球是否进袋
        if isBallInPocket(scene.cueBall) {
            handleCueBallPocketed()
        }
    }

    private func isBallInPocket(_ ball: BallNode) -> Bool {
        guard let scene = scene else { return false }

        let ballPosition = ball.presentation.position
        let pocketRadius = TableNode.pocketRadius

        // 检查四个角袋
        let cornerPockets: [SCNVector3] = [
            SCNVector3(x: -Float(TableNode.tableWidth / 2), y: 0, z: -Float(TableNode.tableLength / 2)),
            SCNVector3(x: Float(TableNode.tableWidth / 2), y: 0, z: -Float(TableNode.tableLength / 2)),
            SCNVector3(x: -Float(TableNode.tableWidth / 2), y: 0, z: Float(TableNode.tableLength / 2)),
            SCNVector3(x: Float(TableNode.tableWidth / 2), y: 0, z: Float(TableNode.tableLength / 2))
        ]

        // 检查两个中袋
        let sidePockets: [SCNVector3] = [
            SCNVector3(x: -Float(TableNode.tableWidth / 2), y: 0, z: 0),
            SCNVector3(x: Float(TableNode.tableWidth / 2), y: 0, z: 0)
        ]

        let allPockets = cornerPockets + sidePockets

        for pocket in allPockets {
            let distance = sqrt(
                pow(ballPosition.x - pocket.x, 2) +
                pow(ballPosition.z - pocket.z, 2)
            )

            if distance < Float(pocketRadius) {
                return true
            }
        }

        return false
    }

    private func handleBallPocketed(_ ball: BallNode) {
        guard let scene = scene else { return }

        // 播放进袋音效
        AudioManager.shared.playSound(.ballPocketed)

        // 从场景中移除
        ball.removeFromParentNode()

        // 从数组中移除
        if let index = scene.targetBalls.firstIndex(of: ball) {
            scene.targetBalls.remove(at: index)
        }

        // 通知观察者
        NotificationCenter.default.post(
            name: .ballPocketed,
            object: nil,
            userInfo: ["ballNumber": ball.ballNumber]
        )
    }

    private func handleCueBallPocketed() {
        // 播放音效
        AudioManager.shared.playSound(.cueBallPocketed)

        // 重置主球位置
        scene?.cueBall.position = SCNVector3(x: 0, y: 0.03, z: 1.5)
        scene?.cueBall.stop()

        // 通知观察者
        NotificationCenter.default.post(name: .cueBallPocketed, object: nil)
    }

    // MARK: - Shooting

    func shootBall(force: SCNVector3, spin: SpinType = .none) {
        guard let scene = scene else { return }

        // 应用击球力
        scene.cueBall.applyForce(force)

        // 应用旋转
        switch spin {
        case .none:
            break
        case .topSpin:
            scene.cueBall.applySpin(horizontal: 0, vertical: 1)
        case .backSpin:
            scene.cueBall.applySpin(horizontal: 0, vertical: -1)
        case .leftSpin:
            scene.cueBall.applySpin(horizontal: -1, vertical: 0)
        case .rightSpin:
            scene.cueBall.applySpin(horizontal: 1, vertical: 0)
        case .custom(let h, let v):
            scene.cueBall.applySpin(horizontal: h, vertical: v)
        }

        // 播放击球音效
        AudioManager.shared.playSound(.cueHit)
    }

    // MARK: - State

    var allBallsStopped: Bool {
        guard let scene = scene else { return true }

        if scene.cueBall.isMoving {
            return false
        }

        for ball in scene.targetBalls {
            if ball.isMoving {
                return false
            }
        }

        return true
    }
}

// MARK: - Spin Type

enum SpinType {
    case none
    case topSpin    // 高杆
    case backSpin   // 低杆
    case leftSpin   // 左偏杆
    case rightSpin  // 右偏杆
    case custom(horizontal: Float, vertical: Float)
}

// MARK: - Notifications

extension Notification.Name {
    static let ballPocketed = Notification.Name("ballPocketed")
    static let cueBallPocketed = Notification.Name("cueBallPocketed")
    static let ballCollision = Notification.Name("ballCollision")
}
```

**验收标准**:
- [ ] PhysicsEngine类已创建
- [ ] 物理世界配置正确
- [ ] 摩擦力系统实现
- [ ] 进袋检测实现
- [ ] 击球功能实现

---

## 二、创建碰撞处理器

### 2.1 创建 CollisionHandler.swift

**位置**: `Core/Physics/CollisionHandler.swift`

**代码**:
```swift
import SceneKit

class CollisionHandler: NSObject, SCNPhysicsContactDelegate {
    weak var engine: PhysicsEngine?

    init(engine: PhysicsEngine) {
        self.engine = engine
        super.init()
    }

    // MARK: - SCNPhysicsContactDelegate

    func physicsWorld(_ world: SCNPhysicsWorld, didBegin contact: SCNPhysicsContact) {
        let nodeA = contact.nodeA
        let nodeB = contact.nodeB

        // 球与球碰撞
        if let ballA = nodeA as? BallNode, let ballB = nodeB as? BallNode {
            handleBallToBallCollision(ballA, ballB, contact: contact)
        }
        // 球与边库碰撞
        else if isBallAndCushion(nodeA, nodeB) {
            handleBallToCushionCollision(contact)
        }
        // 球与球袋碰撞
        else if isBallAndPocket(nodeA, nodeB) {
            // 进袋检测在PhysicsEngine中处理
        }
    }

    func physicsWorld(_ world: SCNPhysicsWorld, didUpdate contact: SCNPhysicsContact) {
        // 持续接触时的处理
    }

    func physicsWorld(_ world: SCNPhysicsWorld, didEnd contact: SCNPhysicsContact) {
        // 接触结束时的处理
    }

    // MARK: - Ball to Ball Collision

    private func handleBallToBallCollision(_ ballA: BallNode, _ ballB: BallNode, contact: SCNPhysicsContact) {
        // 播放碰撞音效
        let impactVelocity = contact.collisionImpulse
        playCollisionSound(intensity: Float(impactVelocity))

        // 震动反馈
        if impactVelocity > 0.5 {
            HapticManager.shared.impact(style: .medium)
        }

        // 发送碰撞通知
        NotificationCenter.default.post(
            name: .ballCollision,
            object: nil,
            userInfo: [
                "ballA": ballA.ballNumber,
                "ballB": ballB.ballNumber,
                "impulse": impactVelocity
            ]
        )

        // 应用真实的碰撞物理
        applyCollisionPhysics(ballA, ballB, contact: contact)
    }

    private func applyCollisionPhysics(_ ballA: BallNode, _ ballB: BallNode, contact: SCNPhysicsContact) {
        guard let bodyA = ballA.physicsBody,
              let bodyB = ballB.physicsBody else { return }

        // 获取碰撞点和法线
        let contactPoint = contact.contactPoint
        let contactNormal = contact.contactNormal

        // 计算相对速度
        let relativeVelocity = SCNVector3(
            x: bodyA.velocity.x - bodyB.velocity.x,
            y: bodyA.velocity.y - bodyB.velocity.y,
            z: bodyA.velocity.z - bodyB.velocity.z
        )

        // 计算沿法线方向的速度
        let velocityAlongNormal = dotProduct(relativeVelocity, contactNormal)

        // 如果球正在分离，不处理
        if velocityAlongNormal > 0 {
            return
        }

        // 计算反弹系数
        let restitution: Float = 0.95

        // 计算冲量标量
        let impulseScalar = -(1 + restitution) * velocityAlongNormal
        let totalMass = Float(bodyA.mass + bodyB.mass)
        let impulse = impulseScalar / totalMass

        // 应用冲量
        let impulseVector = SCNVector3(
            x: contactNormal.x * impulse,
            y: contactNormal.y * impulse,
            z: contactNormal.z * impulse
        )

        bodyA.applyForce(
            SCNVector3(
                x: impulseVector.x * Float(bodyB.mass),
                y: impulseVector.y * Float(bodyB.mass),
                z: impulseVector.z * Float(bodyB.mass)
            ),
            asImpulse: true
        )

        bodyB.applyForce(
            SCNVector3(
                x: -impulseVector.x * Float(bodyA.mass),
                y: -impulseVector.y * Float(bodyA.mass),
                z: -impulseVector.z * Float(bodyA.mass)
            ),
            asImpulse: true
        )
    }

    // MARK: - Ball to Cushion Collision

    private func handleBallToCushionCollision(_ contact: SCNPhysicsContact) {
        // 播放边库碰撞音效
        let impactVelocity = contact.collisionImpulse
        playCollisionSound(intensity: Float(impactVelocity) * 0.8)

        // 震动反馈
        if impactVelocity > 0.3 {
            HapticManager.shared.impact(style: .light)
        }
    }

    // MARK: - Helper Methods

    private func isBallAndCushion(_ nodeA: SCNNode, _ nodeB: SCNNode) -> Bool {
        let categoryA = nodeA.physicsBody?.categoryBitMask ?? 0
        let categoryB = nodeB.physicsBody?.categoryBitMask ?? 0

        return (categoryA == PhysicsCategory.ball && categoryB == PhysicsCategory.cushion) ||
               (categoryA == PhysicsCategory.cushion && categoryB == PhysicsCategory.ball)
    }

    private func isBallAndPocket(_ nodeA: SCNNode, _ nodeB: SCNNode) -> Bool {
        let categoryA = nodeA.physicsBody?.categoryBitMask ?? 0
        let categoryB = nodeB.physicsBody?.categoryBitMask ?? 0

        return (categoryA == PhysicsCategory.ball && categoryB == PhysicsCategory.pocket) ||
               (categoryA == PhysicsCategory.pocket && categoryB == PhysicsCategory.ball)
    }

    private func playCollisionSound(intensity: Float) {
        if intensity > 1.0 {
            AudioManager.shared.playSound(.ballCollisionHard)
        } else if intensity > 0.3 {
            AudioManager.shared.playSound(.ballCollisionMedium)
        } else {
            AudioManager.shared.playSound(.ballCollisionSoft)
        }
    }

    private func dotProduct(_ a: SCNVector3, _ b: SCNVector3) -> Float {
        return a.x * b.x + a.y * b.y + a.z * b.z
    }
}
```

**验收标准**:
- [ ] CollisionHandler类已创建
- [ ] 球与球碰撞处理正确
- [ ] 球与边库碰撞处理正确
- [ ] 碰撞音效正常
- [ ] 震动反馈正常

---

## 三、创建物理常数配置

### 3.1 创建 PhysicsConstants.swift

**位置**: `Utilities/Constants/PhysicsConstants.swift`

**代码**:
```swift
import Foundation
import CoreGraphics

struct PhysicsConstants {
    // 球的物理属性
    static let ballRadius: CGFloat = 0.028575 // 57.15mm
    static let ballMass: CGFloat = 0.17 // 170g
    static let ballRestitution: CGFloat = 0.95 // 弹性系数
    static let ballFriction: CGFloat = 0.3 // 摩擦系数
    static let ballRollingFriction: CGFloat = 0.01 // 滚动摩擦

    // 球台物理属性
    static let tableLength: CGFloat = 2.54 // 2.54m
    static let tableWidth: CGFloat = 1.27 // 1.27m
    static let tableHeight: CGFloat = 0.8 // 0.8m
    static let tableFriction: CGFloat = 0.2 // 台呢摩擦系数
    static let tableRestitution: CGFloat = 0.8 // 台面弹性

    // 边库物理属性
    static let cushionRestitution: CGFloat = 0.9 // 边库弹性
    static let cushionFriction: CGFloat = 0.1 // 边库摩擦
    static let cushionHeight: CGFloat = 0.04 // 边库高度

    // 球袋属性
    static let pocketRadius: CGFloat = 0.06 // 球袋半径

    // 力的参数
    static let minShotForce: Float = 0.5 // 最小击球力
    static let maxShotForce: Float = 10.0 // 最大击球力
    static let defaultShotForce: Float = 5.0 // 默认击球力

    // 旋转参数
    static let maxSpinValue: Float = 1.0 // 最大旋转值
    static let spinMultiplier: Float = 10.0 // 旋转倍数

    // 物理世界参数
    static let gravity: Float = 9.8 // 重力加速度
    static let airResistance: Float = 0.01 // 空气阻力
    static let timeStep: Double = 1.0 / 60.0 // 物理时间步长

    // 停止阈值
    static let velocityThreshold: Float = 0.01 // 速度阈值
    static let angularVelocityThreshold: Float = 0.01 // 角速度阈值
}
```

**验收标准**:
- [ ] PhysicsConstants已创建
- [ ] 所有常数定义完整
- [ ] 数值符合真实台球物理

---

## 四、集成物理引擎到场景

### 4.1 更新 BilliardScene.swift

在 `BilliardScene.swift` 中添加：

```swift
class BilliardScene: SCNScene {
    // ... 现有代码 ...

    // 物理引擎
    var physicsEngine: PhysicsEngine!

    override init() {
        super.init()
        setupScene()

        // 初始化物理引擎
        physicsEngine = PhysicsEngine(scene: self)
    }

    // ... 现有代码 ...

    func update(deltaTime: TimeInterval) {
        physicsEngine.update(deltaTime: deltaTime)
    }
}
```

### 4.2 更新 BilliardSceneView.swift

更新渲染代理：

```swift
class Coordinator: NSObject, SCNSceneRendererDelegate {
    var parent: BilliardSceneView
    var lastUpdateTime: TimeInterval = 0

    init(_ parent: BilliardSceneView) {
        self.parent = parent
    }

    func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) {
        // 计算deltaTime
        let deltaTime = lastUpdateTime == 0 ? 0 : time - lastUpdateTime
        lastUpdateTime = time

        // 更新物理引擎
        if let scene = parent.scene {
            scene.update(deltaTime: deltaTime)
        }
    }
}
```

**验收标准**:
- [ ] 物理引擎已集成到场景
- [ ] 每帧更新正常
- [ ] deltaTime计算正确

---

## 五、创建辅助工具类

### 5.1 创建 HapticManager.swift

**位置**: `Core/Audio/HapticManager.swift`

**代码**:
```swift
import UIKit

class HapticManager {
    static let shared = HapticManager()

    private let impactLight = UIImpactFeedbackGenerator(style: .light)
    private let impactMedium = UIImpactFeedbackGenerator(style: .medium)
    private let impactHeavy = UIImpactFeedbackGenerator(style: .heavy)
    private let selection = UISelectionFeedbackGenerator()
    private let notification = UINotificationFeedbackGenerator()

    private init() {
        // 预加载
        impactLight.prepare()
        impactMedium.prepare()
        impactHeavy.prepare()
    }

    func impact(style: UIImpactFeedbackGenerator.FeedbackStyle) {
        guard UserDefaults.standard.bool(forKey: "vibrationEnabled") else { return }

        switch style {
        case .light:
            impactLight.impactOccurred()
            impactLight.prepare()
        case .medium:
            impactMedium.impactOccurred()
            impactMedium.prepare()
        case .heavy:
            impactHeavy.impactOccurred()
            impactHeavy.prepare()
        @unknown default:
            break
        }
    }

    func selection() {
        guard UserDefaults.standard.bool(forKey: "vibrationEnabled") else { return }
        selection.selectionChanged()
    }

    func notification(type: UINotificationFeedbackGenerator.FeedbackType) {
        guard UserDefaults.standard.bool(forKey: "vibrationEnabled") else { return }
        notification.notificationOccurred(type)
    }
}
```

**验收标准**:
- [ ] HapticManager已创建
- [ ] 震动反馈正常工作
- [ ] 可以根据设置开关

---

## 六、测试物理引擎

### 6.1 更新测试视图

更新 `SceneTestView.swift`：

```swift
struct SceneTestView: View {
    @State private var scene: BilliardScene?
    @State private var shotForce: Float = 5.0
    @State private var spinType: SpinType = .none

    var body: some View {
        VStack {
            BilliardSceneView(scene: $scene)
                .ignoresSafeArea()

            VStack(spacing: 15) {
                // 力度控制
                VStack {
                    Text("击球力度: \(String(format: "%.1f", shotForce))")
                        .font(.caption)
                    Slider(value: $shotForce, in: 0.5...10.0)
                }

                // 旋转选择
                Picker("旋转", selection: $spinType) {
                    Text("无").tag(SpinType.none)
                    Text("高杆").tag(SpinType.topSpin)
                    Text("低杆").tag(SpinType.backSpin)
                    Text("左偏").tag(SpinType.leftSpin)
                    Text("右偏").tag(SpinType.rightSpin)
                }
                .pickerStyle(.segmented)

                HStack(spacing: 20) {
                    Button("添加球") {
                        addRandomBall()
                    }
                    .buttonStyle(.borderedProminent)

                    Button("击球") {
                        shootBall()
                    }
                    .buttonStyle(.borderedProminent)
                    .tint(.green)

                    Button("重置") {
                        scene?.resetBalls()
                    }
                    .buttonStyle(.bordered)
                }
            }
            .padding()
        }
    }

    private func addRandomBall() {
        guard let scene = scene else { return }

        let x = Float.random(in: -0.5...0.5)
        let z = Float.random(in: -1.0...1.0)
        let position = SCNVector3(x: x, y: 0.03, z: z)
        let number = Int.random(in: 1...15)

        scene.addTargetBall(at: position, number: number)
    }

    private func shootBall() {
        guard let scene = scene else { return }

        let force = SCNVector3(x: 0, y: 0, z: -shotForce)
        scene.physicsEngine.shootBall(force: force, spin: spinType)
    }
}
```

**验收标准**:
- [ ] 可以调整击球力度
- [ ] 可以选择旋转类型
- [ ] 击球效果符合预期
- [ ] 物理效果真实

---

## 七、性能优化

### 7.1 优化碰撞检测

在 `PhysicsEngine.swift` 中添加：

```swift
// 使用空间分区优化碰撞检测
private func optimizeCollisionDetection() {
    // 只检测可能碰撞的球
    // 使用简单的距离检查
}
```

### 7.2 优化物理计算

```swift
// 当球静止时，禁用物理计算
private func optimizePhysicsCalculation() {
    guard let scene = scene else { return }

    for ball in scene.targetBalls {
        if !ball.isMoving {
            ball.physicsBody?.isAffectedByGravity = false
        } else {
            ball.physicsBody?.isAffectedByGravity = true
        }
    }
}
```

**验收标准**:
- [ ] 碰撞检测优化完成
- [ ] 物理计算优化完成
- [ ] 性能提升明显

---

## 八、常见问题和解决方案

### 问题1：球的速度衰减不自然

**解决方案**:
```swift
// 调整摩擦系数
private let tableFriction: Float = 0.2 // 增加或减少此值
private let rollingResistance: Float = 0.01 // 调整滚动阻力
```

### 问题2：碰撞后球的运动不真实

**解决方案**:
```swift
// 调整弹性系数
let restitution: Float = 0.95 // 降低此值会减少弹性
```

### 问题3：球容易穿透边库

**解决方案**:
```swift
// 增加碰撞边距
let shape = SCNPhysicsShape(
    geometry: geometry,
    options: [.collisionMargin: 0.002] // 增加此值
)
```

---

## 九、提交代码

```bash
git add .
git commit -m "feat: Implement physics engine

- Created PhysicsEngine with friction and air resistance
- Implemented CollisionHandler for ball collisions
- Added PhysicsConstants for configuration
- Implemented HapticManager for feedback
- Integrated physics engine into scene
- Added comprehensive testing controls
"
```

---

## 十、最终验收清单

- [ ] PhysicsEngine完整实现
- [ ] CollisionHandler正常工作
- [ ] 摩擦力系统正确
- [ ] 碰撞检测准确
- [ ] 进袋检测正常
- [ ] 旋转系统实现
- [ ] 震动反馈正常
- [ ] 性能优化完成
- [ ] 测试通过
- [ ] 代码已提交

---

## 下一步

完成本步骤后，继续进行：
- **步骤4**: 瞄准系统实现
- **步骤5**: 相机系统实现

---

**预计完成时间**: 4-5天
**实际完成时间**: ___________
**遇到的问题**: ___________
**解决方案**: ___________