# 步骤5：相机系统实现

## 目标
实现完整的相机系统，包括多视角切换、手势控制、平滑过渡。

**预计时间**: 2-3天
**优先级**: P0（必须完成）

---

## 一、创建相机管理器

### 1.1 创建 CameraManager.swift

**位置**: `Core/Scene/CameraManager.swift`

**代码**:
```swift
import SceneKit

enum CameraMode {
    case topView        // 俯视图
    case sideView       // 侧视图
    case followBall     // 跟随主球
    case free           // 自由视角
    case aimView        // 瞄准视角
}

class CameraManager {
    weak var scene: BilliardScene?
    private var cameraNode: SCNNode
    private var cameraTarget: SCNNode
    
    var currentMode: CameraMode = .topView
    private var isTransitioning: Bool = false
    
    // 相机参数
    private let transitionDuration: TimeInterval = 0.5
    private var targetPosition: SCNVector3?
    private var targetRotation: SCNVector3?
    
    init(scene: BilliardScene, cameraNode: SCNNode, cameraTarget: SCNNode) {
        self.scene = scene
        self.cameraNode = cameraNode
        self.cameraTarget = cameraTarget
    }
    
    // MARK: - Camera Modes
    
    func switchToMode(_ mode: CameraMode, animated: Bool = true) {
        currentMode = mode
        
        let (position, rotation) = getCameraTransform(for: mode)
        
        if animated {
            animateCamera(to: position, rotation: rotation)
        } else {
            cameraNode.position = position
            cameraNode.eulerAngles = rotation
        }
    }
    
    private func getCameraTransform(for mode: CameraMode) -> (SCNVector3, SCNVector3) {
        guard let scene = scene else {
            return (SCNVector3(x: 0, y: 3, z: 5), SCNVector3(x: -.pi / 4, y: 0, z: 0))
        }
        
        let cueBallPos = scene.cueBall.position
        
        switch mode {
        case .topView:
            return (
                SCNVector3(x: 0, y: 5, z: 0),
                SCNVector3(x: -.pi / 2, y: 0, z: 0)
            )
            
        case .sideView:
            return (
                SCNVector3(x: 0, y: 2, z: 4),
                SCNVector3(x: -.pi / 6, y: 0, z: 0)
            )
            
        case .followBall:
            return (
                SCNVector3(x: cueBallPos.x, y: cueBallPos.y + 1.5, z: cueBallPos.z + 2),
                SCNVector3(x: -.pi / 4, y: 0, z: 0)
            )
            
        case .aimView:
            // 从主球后方看向目标
            let offset: Float = 0.5
            return (
                SCNVector3(x: cueBallPos.x, y: cueBallPos.y + 0.3, z: cueBallPos.z + offset),
                SCNVector3(x: -.pi / 8, y: 0, z: 0)
            )
            
        case .free:
            return (cameraNode.position, cameraNode.eulerAngles)
        }
    }
    
    private func animateCamera(to position: SCNVector3, rotation: SCNVector3) {
        isTransitioning = true
        
        SCNTransaction.begin()
        SCNTransaction.animationDuration = transitionDuration
        SCNTransaction.animationTimingFunction = CAMediaTimingFunction(name: .easeInEaseOut)
        SCNTransaction.completionBlock = {
            self.isTransitioning = false
        }
        
        cameraNode.position = position
        cameraNode.eulerAngles = rotation
        
        SCNTransaction.commit()
    }
    
    // MARK: - Update
    
    func update() {
        guard !isTransitioning else { return }
        
        switch currentMode {
        case .followBall:
            updateFollowBallCamera()
        case .aimView:
            updateAimViewCamera()
        default:
            break
        }
    }
    
    private func updateFollowBallCamera() {
        guard let scene = scene else { return }
        
        let cueBallPos = scene.cueBall.position
        let targetPos = SCNVector3(
            x: cueBallPos.x,
            y: cueBallPos.y + 1.5,
            z: cueBallPos.z + 2
        )
        
        // 平滑跟随
        let smoothing: Float = 0.1
        cameraNode.position = SCNVector3(
            x: cameraNode.position.x + (targetPos.x - cameraNode.position.x) * smoothing,
            y: cameraNode.position.y + (targetPos.y - cameraNode.position.y) * smoothing,
            z: cameraNode.position.z + (targetPos.z - cameraNode.position.z) * smoothing
        )
        
        cameraNode.look(at: cueBallPos)
    }
    
    private func updateAimViewCamera() {
        guard let scene = scene else { return }
        
        let cueBallPos = scene.cueBall.position
        let aimDir = scene.aimingSystem.aimDirection
        
        // 相机位于主球后方
        let offset: Float = 0.5
        let targetPos = SCNVector3(
            x: cueBallPos.x - aimDir.x * offset,
            y: cueBallPos.y + 0.3,
            z: cueBallPos.z - aimDir.z * offset
        )
        
        cameraNode.position = targetPos
        cameraNode.look(at: SCNVector3(
            x: cueBallPos.x + aimDir.x,
            y: cueBallPos.y,
            z: cueBallPos.z + aimDir.z
        ))
    }
    
    // MARK: - Gesture Control
    
    func handlePinch(scale: CGFloat) {
        guard currentMode == .free else { return }
        
        let currentDistance = distance(cameraNode.position, cameraTarget.position)
        let newDistance = Float(currentDistance / scale)
        
        // 限制缩放范围
        let minDistance: Float = 1.0
        let maxDistance: Float = 10.0
        let clampedDistance = max(minDistance, min(maxDistance, newDistance))
        
        // 计算新位置
        let direction = normalize(
            SCNVector3(
                x: cameraNode.position.x - cameraTarget.position.x,
                y: cameraNode.position.y - cameraTarget.position.y,
                z: cameraNode.position.z - cameraTarget.position.z
            )
        )
        
        cameraNode.position = SCNVector3(
            x: cameraTarget.position.x + direction.x * clampedDistance,
            y: cameraTarget.position.y + direction.y * clampedDistance,
            z: cameraTarget.position.z + direction.z * clampedDistance
        )
    }
    
    func handleRotation(delta: CGPoint) {
        guard currentMode == .free else { return }
        
        let sensitivity: Float = 0.005
        let deltaX = Float(delta.x) * sensitivity
        let deltaY = Float(delta.y) * sensitivity
        
        // 围绕目标点旋转
        let radius = distance(cameraNode.position, cameraTarget.position)
        
        var angles = cameraNode.eulerAngles
        angles.y -= deltaX
        angles.x -= deltaY
        
        // 限制垂直角度
        angles.x = max(-.pi / 2 + 0.1, min(-.pi / 12, angles.x))
        
        cameraNode.eulerAngles = angles
        
        // 更新位置
        let x = sin(angles.y) * cos(angles.x) * radius
        let y = sin(angles.x) * radius
        let z = cos(angles.y) * cos(angles.x) * radius
        
        cameraNode.position = SCNVector3(
            x: cameraTarget.position.x + x,
            y: cameraTarget.position.y - y,
            z: cameraTarget.position.z + z
        )
    }
    
    // MARK: - Helper Methods
    
    private func distance(_ a: SCNVector3, _ b: SCNVector3) -> Float {
        let dx = a.x - b.x
        let dy = a.y - b.y
        let dz = a.z - b.z
        return sqrt(dx * dx + dy * dy + dz * dz)
    }
    
    private func normalize(_ vector: SCNVector3) -> SCNVector3 {
        let length = sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z)
        return SCNVector3(x: vector.x / length, y: vector.y / length, z: vector.z / length)
    }
}
```

**验收标准**:
- [ ] CameraManager类已创建
- [ ] 多种相机模式实现
- [ ] 相机切换动画流畅
- [ ] 手势控制正常

---

## 二、集成相机系统

### 2.1 更新 BilliardScene.swift

```swift
class BilliardScene: SCNScene {
    // ... 现有代码 ...
    
    var cameraManager: CameraManager!
    
    override init() {
        super.init()
        setupScene()
        
        physicsEngine = PhysicsEngine(scene: self)
        aimingSystem = AimingSystem(scene: self)
        diamondSystem = DiamondSystem(scene: self)
        cameraManager = CameraManager(
            scene: self,
            cameraNode: cameraNode,
            cameraTarget: cameraTarget
        )
    }
    
    func update(deltaTime: TimeInterval) {
        physicsEngine.update(deltaTime: deltaTime)
        cameraManager.update()
        
        if let targetBall = targetBall {
            aimingSystem.update(targetBall: targetBall)
        }
    }
}
```

**验收标准**:
- [ ] CameraManager已集成
- [ ] 相机每帧更新正常

---

## 三、创建相机控制UI

### 3.1 创建 CameraControlView.swift

**位置**: `Features/Training/Views/CameraControlView.swift`

**代码**:
```swift
import SwiftUI

struct CameraControlView: View {
    @Binding var scene: BilliardScene?
    @State private var selectedMode: CameraMode = .topView
    
    var body: some View {
        VStack(spacing: 10) {
            Text("视角")
                .font(.caption)
                .foregroundStyle(.secondary)
            
            HStack(spacing: 8) {
                CameraButton(
                    icon: "arrow.down.to.line",
                    title: "俯视",
                    isSelected: selectedMode == .topView
                ) {
                    switchCamera(to: .topView)
                }
                
                CameraButton(
                    icon: "arrow.left.and.right",
                    title: "侧视",
                    isSelected: selectedMode == .sideView
                ) {
                    switchCamera(to: .sideView)
                }
                
                CameraButton(
                    icon: "location.fill",
                    title: "跟随",
                    isSelected: selectedMode == .followBall
                ) {
                    switchCamera(to: .followBall)
                }
                
                CameraButton(
                    icon: "scope",
                    title: "瞄准",
                    isSelected: selectedMode == .aimView
                ) {
                    switchCamera(to: .aimView)
                }
                
                CameraButton(
                    icon: "hand.draw",
                    title: "自由",
                    isSelected: selectedMode == .free
                ) {
                    switchCamera(to: .free)
                }
            }
        }
        .padding()
        .background(Color(.systemBackground).opacity(0.9))
        .cornerRadius(10)
    }
    
    private func switchCamera(to mode: CameraMode) {
        selectedMode = mode
        scene?.cameraManager.switchToMode(mode)
        HapticManager.shared.selection()
    }
}

struct CameraButton: View {
    let icon: String
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 4) {
                Image(systemName: icon)
                    .font(.system(size: 16))
                Text(title)
                    .font(.caption2)
            }
            .frame(width: 60, height: 50)
            .background(isSelected ? Color.green.opacity(0.2) : Color.clear)
            .cornerRadius(8)
        }
        .foregroundColor(isSelected ? .green : .primary)
    }
}
```

**验收标准**:
- [ ] 相机控制UI已创建
- [ ] 可以切换不同视角
- [ ] 选中状态正确显示

---

## 四、添加手势支持

### 4.1 更新 BilliardSceneView.swift

```swift
func makeUIView(context: Context) -> SCNView {
    let sceneView = SCNView()
    
    // ... 现有配置 ...
    
    // 添加捏合手势（缩放）
    let pinchGesture = UIPinchGestureRecognizer(
        target: context.coordinator,
        action: #selector(Coordinator.handlePinch(_:))
    )
    sceneView.addGestureRecognizer(pinchGesture)
    
    // 添加旋转手势
    let rotationGesture = UIRotationGestureRecognizer(
        target: context.coordinator,
        action: #selector(Coordinator.handleRotation(_:))
    )
    sceneView.addGestureRecognizer(rotationGesture)
    
    // 双指拖动手势
    let twoFingerPan = UIPanGestureRecognizer(
        target: context.coordinator,
        action: #selector(Coordinator.handleTwoFingerPan(_:))
    )
    twoFingerPan.minimumNumberOfTouches = 2
    twoFingerPan.maximumNumberOfTouches = 2
    sceneView.addGestureRecognizer(twoFingerPan)
    
    return sceneView
}

class Coordinator: NSObject, SCNSceneRendererDelegate {
    // ... 现有代码 ...
    
    @objc func handlePinch(_ gesture: UIPinchGestureRecognizer) {
        guard let scene = parent.scene else { return }
        
        if gesture.state == .changed {
            scene.cameraManager.handlePinch(scale: gesture.scale)
            gesture.scale = 1.0
        }
    }
    
    @objc func handleRotation(_ gesture: UIRotationGestureRecognizer) {
        // 可用于旋转相机或其他对象
    }
    
    @objc func handleTwoFingerPan(_ gesture: UIPanGestureRecognizer) {
        guard let sceneView = gesture.view as? SCNView else { return }
        guard let scene = parent.scene else { return }
        
        if gesture.state == .changed {
            let translation = gesture.translation(in: sceneView)
            scene.cameraManager.handleRotation(delta: translation)
            gesture.setTranslation(.zero, in: sceneView)
        }
    }
}
```

**验收标准**:
- [ ] 捏合缩放手势正常
- [ ] 双指旋转手势正常
- [ ] 手势响应流畅

---

## 五、优化相机体验

### 5.1 添加相机约束

在 `CameraManager.swift` 中添加：

```swift
// MARK: - Constraints

private func applyConstraints() {
    // 限制相机不穿透球台
    let minY: Float = 0.5
    if cameraNode.position.y < minY {
        cameraNode.position.y = minY
    }
    
    // 限制相机不超出边界
    let maxDistance: Float = 10.0
    let distance = distance(cameraNode.position, cameraTarget.position)
    if distance > maxDistance {
        let direction = normalize(
            SCNVector3(
                x: cameraNode.position.x - cameraTarget.position.x,
                y: cameraNode.position.y - cameraTarget.position.y,
                z: cameraNode.position.z - cameraTarget.position.z
            )
        )
        cameraNode.position = SCNVector3(
            x: cameraTarget.position.x + direction.x * maxDistance,
            y: cameraTarget.position.y + direction.y * maxDistance,
            z: cameraTarget.position.z + direction.z * maxDistance
        )
    }
}

func update() {
    guard !isTransitioning else { return }
    
    switch currentMode {
    case .followBall:
        updateFollowBallCamera()
    case .aimView:
        updateAimViewCamera()
    default:
        break
    }
    
    applyConstraints()
}
```

### 5.2 添加相机震动效果

```swift
func shake(intensity: Float = 0.1) {
    let originalPosition = cameraNode.position
    
    SCNTransaction.begin()
    SCNTransaction.animationDuration = 0.05
    
    cameraNode.position = SCNVector3(
        x: originalPosition.x + Float.random(in: -intensity...intensity),
        y: originalPosition.y + Float.random(in: -intensity...intensity),
        z: originalPosition.z + Float.random(in: -intensity...intensity)
    )
    
    SCNTransaction.completionBlock = {
        SCNTransaction.begin()
        SCNTransaction.animationDuration = 0.05
        self.cameraNode.position = originalPosition
        SCNTransaction.commit()
    }
    
    SCNTransaction.commit()
}
```

**验收标准**:
- [ ] 相机约束正常工作
- [ ] 相机震动效果实现

---

## 六、测试相机系统

### 6.1 更新测试视图

```swift
struct SceneTestView: View {
    @State private var scene: BilliardScene?
    
    var body: some View {
        ZStack {
            BilliardSceneView(scene: $scene)
                .ignoresSafeArea()
            
            VStack {
                HStack {
                    Spacer()
                    CameraControlView(scene: $scene)
                        .padding()
                }
                
                Spacer()
                
                if scene != nil {
                    AimingControlView(scene: $scene)
                        .padding()
                }
            }
        }
        .onAppear {
            setupTestScene()
        }
    }
    
    private func setupTestScene() {
        guard let scene = scene else { return }
        
        // 添加测试球
        scene.addTargetBall(at: SCNVector3(x: 0, y: 0.03, z: 0), number: 1)
        scene.addTargetBall(at: SCNVector3(x: 0.2, y: 0.03, z: -0.5), number: 2)
        scene.addTargetBall(at: SCNVector3(x: -0.2, y: 0.03, z: -0.5), number: 3)
        
        // 设置初始相机
        scene.cameraManager.switchToMode(.topView, animated: false)
    }
}
```

**验收标准**:
- [ ] 相机控制UI正确显示
- [ ] 所有视角切换正常
- [ ] 手势控制流畅

---

## 七、常见问题和解决方案

### 问题1：相机切换时出现跳跃

**解决方案**:
```swift
// 使用更长的过渡时间
private let transitionDuration: TimeInterval = 0.8

// 使用更平滑的时间函数
SCNTransaction.animationTimingFunction = CAMediaTimingFunction(name: .easeInEaseOut)
```

### 问题2：跟随模式下相机抖动

**解决方案**:
```swift
// 增加平滑系数
let smoothing: Float = 0.05 // 降低此值使跟随更平滑
```

### 问题3：自由视角下相机控制不灵敏

**解决方案**:
```swift
// 调整灵敏度
let sensitivity: Float = 0.01 // 增加此值提高灵敏度
```

---

## 八、提交代码

```bash
git add .
git commit -m "feat: Implement camera system
A a
- Created CameraManager with multiple camera modes
- Implemented smooth camera transitions
- Added gesture controls for camera manipulation
- Created CameraControlView for UI
- Added camera constraints and shake effect
- Integrated camera system into scene
"
```

---

## 九、最终验收清单

- [ ] CameraManager完整实现
- [ ] 多种相机模式正常工作
- [ ] 相机切换动画流畅
- [ ] 手势控制完善
- [ ] 相机约束正确
- [ ] UI控制完善
- [ ] 测试通过
- [ ] 代码已提交

---

## 下一步

完成本步骤后，继续进行：
- **步骤6**: 课程系统实现
- **步骤7**: 训练场实现

---

**预计完成时间**: 2-3天
**实际完成时间**: ___________
**遇到的问题**: ___________
**解决方案**: ___________
