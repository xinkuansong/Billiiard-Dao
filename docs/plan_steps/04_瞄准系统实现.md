# 步骤4：瞄准系统实现

## 目标
实现完整的瞄准系统，包括瞄准线、假想球、分离角计算。

**预计时间**: 3-4天
**优先级**: P0（必须完成）

---

## 一、创建瞄准系统核心

### 1.1 创建 AimingSystem.swift

**位置**: `Core/Aiming/AimingSystem.swift`

**代码**:
```swift
import SceneKit

class AimingSystem {
    weak var scene: BilliardScene?
    
    // 瞄准线节点
    private var aimLine: SCNNode?
    private var ghostBall: SCNNode?
    private var trajectoryLine: SCNNode?
    
    // 瞄准参数
    var aimDirection: SCNVector3 = SCNVector3(x: 0, y: 0, z: -1)
    var aimPower: Float = 5.0
    
    // 设置
    var showAimLine: Bool = true
    var showGhostBall: Bool = true
    var showTrajectory: Bool = false
    
    init(scene: BilliardScene) {
        self.scene = scene
        setupAimingVisuals()
    }
    
    private func setupAimingVisuals() {
        createAimLine()
        createGhostBall()
        createTrajectoryLine()
    }
    
    // MARK: - Aim Line
    
    private func createAimLine() {
        // 创建瞄准线几何
        let line = SCNCylinder(radius: 0.002, height: 3.0)
        let material = SCNMaterial()
        material.diffuse.contents = UIColor.white.withAlphaComponent(0.8)
        material.emission.contents = UIColor.white.withAlphaComponent(0.3)
        line.materials = [material]
        
        aimLine = SCNNode(geometry: line)
        aimLine?.eulerAngles = SCNVector3(x: .pi / 2, y: 0, z: 0)
        aimLine?.isHidden = !showAimLine
    }
    
    // MARK: - Ghost Ball
    
    private func createGhostBall() {
        let sphere = SCNSphere(radius: BallNode.ballRadius)
        let material = SCNMaterial()
        material.diffuse.contents = UIColor.white.withAlphaComponent(0.3)
        material.transparency = 0.3
        sphere.materials = [material]
        
        ghostBall = SCNNode(geometry: sphere)
        ghostBall?.isHidden = !showGhostBall
    }
    
    // MARK: - Trajectory Line
    
    private func createTrajectoryLine() {
        let line = SCNCylinder(radius: 0.001, height: 2.0)
        let material = SCNMaterial()
        material.diffuse.contents = UIColor.yellow.withAlphaComponent(0.6)
        line.materials = [material]
        
        trajectoryLine = SCNNode(geometry: line)
        trajectoryLine?.eulerAngles = SCNVector3(x: .pi / 2, y: 0, z: 0)
        trajectoryLine?.isHidden = !showTrajectory
    }
    
    // MARK: - Update
    
    func update(targetBall: BallNode) {
        guard let scene = scene else { return }
        
        let cueBallPos = scene.cueBall.position
        let targetBallPos = targetBall.position
        
        // 计算瞄准方向
        let direction = SCNVector3(
            x: targetBallPos.x - cueBallPos.x,
            y: 0,
            z: targetBallPos.z - cueBallPos.z
        )
        
        let distance = sqrt(direction.x * direction.x + direction.z * direction.z)
        aimDirection = SCNVector3(
            x: direction.x / distance,
            y: 0,
            z: direction.z / distance
        )
        
        // 更新瞄准线
        updateAimLine(from: cueBallPos, direction: aimDirection)
        
        // 更新假想球
        updateGhostBall(targetBall: targetBall)
        
        // 更新轨迹线
        updateTrajectoryLine(targetBall: targetBall)
    }
    
    private func updateAimLine(from position: SCNVector3, direction: SCNVector3) {
        guard let aimLine = aimLine else { return }
        
        // 设置位置
        let lineLength: Float = 1.5
        aimLine.position = SCNVector3(
            x: position.x + direction.x * lineLength / 2,
            y: 0.03,
            z: position.z + direction.z * lineLength / 2
        )
        
        // 设置旋转
        let angle = atan2(direction.x, direction.z)
        aimLine.eulerAngles = SCNVector3(x: .pi / 2, y: -angle, z: 0)
        
        // 添加到场景
        if aimLine.parent == nil {
            scene?.rootNode.addChildNode(aimLine)
        }
    }
    
    private func updateGhostBall(targetBall: BallNode) {
        guard let ghostBall = ghostBall else { return }
        guard let scene = scene else { return }
        
        let cueBallPos = scene.cueBall.position
        let targetBallPos = targetBall.position
        
        // 计算假想球位置（在目标球后方）
        let direction = SCNVector3(
            x: targetBallPos.x - cueBallPos.x,
            y: 0,
            z: targetBallPos.z - cueBallPos.z
        )
        
        let distance = sqrt(direction.x * direction.x + direction.z * direction.z)
        let normalizedDir = SCNVector3(
            x: direction.x / distance,
            y: 0,
            z: direction.z / distance
        )
        
        let ballDiameter = Float(BallNode.ballRadius * 2)
        ghostBall.position = SCNVector3(
            x: targetBallPos.x - normalizedDir.x * ballDiameter,
            y: targetBallPos.y,
            z: targetBallPos.z - normalizedDir.z * ballDiameter
        )
        
        // 添加到场景
        if ghostBall.parent == nil {
            scene.rootNode.addChildNode(ghostBall)
        }
    }
    
    private func updateTrajectoryLine(targetBall: BallNode) {
        guard let trajectoryLine = trajectoryLine else { return }
        guard let scene = scene else { return }
        
        // 计算目标球击打后的轨迹
        let targetBallPos = targetBall.position
        
        // 简化：假设目标球沿着主球到目标球的方向运动
        let direction = aimDirection
        let lineLength: Float = 1.0
        
        trajectoryLine.position = SCNVector3(
            x: targetBallPos.x + direction.x * lineLength / 2,
            y: 0.03,
            z: targetBallPos.z + direction.z * lineLength / 2
        )
        
        let angle = atan2(direction.x, direction.z)
        trajectoryLine.eulerAngles = SCNVector3(x: .pi / 2, y: -angle, z: 0)
        
        // 添加到场景
        if trajectoryLine.parent == nil {
            scene.rootNode.addChildNode(trajectoryLine)
        }
    }
    
    // MARK: - Public Methods
    
    func hide() {
        aimLine?.isHidden = true
        ghostBall?.isHidden = true
        trajectoryLine?.isHidden = true
    }
    
    func show() {
        aimLine?.isHidden = !showAimLine
        ghostBall?.isHidden = !showGhostBall
        trajectoryLine?.isHidden = !showTrajectory
    }
    
    func calculateShotVector() -> SCNVector3 {
        return SCNVector3(
            x: aimDirection.x * aimPower,
            y: 0,
            z: aimDirection.z * aimPower
        )
    }
}
```

**验收标准**:
- [ ] AimingSystem类已创建
- [ ] 瞄准线正确显示
- [ ] 假想球位置正确
- [ ] 轨迹线显示正常

---

## 二、创建钻石系统

### 2.1 创建 DiamondSystem.swift

**位置**: `Core/Aiming/DiamondSystem.swift`

**代码**:
```swift
import SceneKit

class DiamondSystem {
    // 钻石点位置（标准9球桌）
    private var diamondPoints: [SCNVector3] = []
    private var diamondNodes: [SCNNode] = []
    
    weak var scene: BilliardScene?
    var isVisible: Bool = false {
        didSet {
            updateVisibility()
        }
    }
    
    init(scene: BilliardScene) {
        self.scene = scene
        calculateDiamondPoints()
        createDiamondNodes()
    }
    
    private func calculateDiamondPoints() {
        let tableWidth = Float(TableNode.tableWidth)
        let tableLength = Float(TableNode.tableLength)
        
        // 长边钻石点（每边7个）
        for i in 0..<7 {
            let z = -tableLength / 2 + (tableLength / 6) * Float(i)
            // 上边
            diamondPoints.append(SCNVector3(x: -tableWidth / 2, y: 0.04, z: z))
            // 下边
            diamondPoints.append(SCNVector3(x: tableWidth / 2, y: 0.04, z: z))
        }
        
        // 短边钻石点（每边3个）
        for i in 0..<3 {
            let x = -tableWidth / 2 + (tableWidth / 2) * Float(i)
            // 左边
            diamondPoints.append(SCNVector3(x: x, y: 0.04, z: -tableLength / 2))
            // 右边
            diamondPoints.append(SCNVector3(x: x, y: 0.04, z: tableLength / 2))
        }
    }
    
    private func createDiamondNodes() {
        for point in diamondPoints {
            let diamond = SCNBox(width: 0.01, height: 0.005, length: 0.01, chamferRadius: 0.001)
            let material = SCNMaterial()
            material.diffuse.contents = UIColor.white
            material.emission.contents = UIColor.white.withAlphaComponent(0.5)
            diamond.materials = [material]
            
            let node = SCNNode(geometry: diamond)
            node.position = point
            node.isHidden = !isVisible
            
            diamondNodes.append(node)
            scene?.rootNode.addChildNode(node)
        }
    }
    
    private func updateVisibility() {
        for node in diamondNodes {
            node.isHidden = !isVisible
        }
    }
    
    // MARK: - Diamond System Calculation
    
    func calculateBankShot(from: SCNVector3, to: SCNVector3) -> SCNVector3? {
        // 实现钻石系统计算
        // 这是一个简化版本，实际应用中需要更复杂的计算
        
        let tableWidth = Float(TableNode.tableWidth)
        let tableLength = Float(TableNode.tableLength)
        
        // 计算反射点
        // 这里使用简单的镜像反射
        let reflectionPoint = SCNVector3(
            x: -from.x,
            y: from.y,
            z: from.z
        )
        
        return reflectionPoint
    }
}
```

**验收标准**:
- [ ] DiamondSystem类已创建
- [ ] 钻石点位置正确
- [ ] 可以显示/隐藏钻石点
- [ ] 基础计算功能实现

---

## 三、集成瞄准系统

### 3.1 更新 BilliardScene.swift

在 `BilliardScene.swift` 中添加：

```swift
class BilliardScene: SCNScene {
    // ... 现有代码 ...
    
    // 瞄准系统
    var aimingSystem: AimingSystem!
    var diamondSystem: DiamondSystem!
    
    // 当前瞄准的目标球
    var targetBall: BallNode?
    
    override init() {
        super.init()
        setupScene()
        
        physicsEngine = PhysicsEngine(scene: self)
        aimingSystem = AimingSystem(scene: self)
        diamondSystem = DiamondSystem(scene: self)
    }
    
    func update(deltaTime: TimeInterval) {
        physicsEngine.update(deltaTime: deltaTime)
        
        // 更新瞄准系统
        if let targetBall = targetBall {
            aimingSystem.update(targetBall: targetBall)
        }
    }
    
    func setTargetBall(_ ball: BallNode?) {
        targetBall = ball
        if ball == nil {
            aimingSystem.hide()
        } else {
            aimingSystem.show()
        }
    }
}
```

**验收标准**:
- [ ] 瞄准系统已集成
- [ ] 可以设置目标球
- [ ] 瞄准线跟随目标球更新

---

## 四、创建瞄准控制UI

### 4.1 创建 AimingControlView.swift

**位置**: `Features/Training/Views/AimingControlView.swift`

**代码**:
```swift
import SwiftUI

struct AimingControlView: View {
    @Binding var scene: BilliardScene?
    @State private var aimPower: Float = 5.0
    @State private var spinHorizontal: Float = 0.0
    @State private var spinVertical: Float = 0.0
    @State private var showSettings: Bool = false
    
    var body: some View {
        VStack(spacing: 15) {
            // 力度控制
            VStack(alignment: .leading, spacing: 5) {
                HStack {
                    Text("力度")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                    Spacer()
                    Text(String(format: "%.1f", aimPower))
                        .font(.caption)
                        .foregroundStyle(.primary)
                }
                
                Slider(value: $aimPower, in: 0.5...10.0)
                    .tint(.green)
                    .onChange(of: aimPower) { _, newValue in
                        scene?.aimingSystem.aimPower = newValue
                    }
            }
            
            // 旋转控制
            VStack(alignment: .leading, spacing: 5) {
                Text("旋转控制")
                    .font(.caption)
                    .foregroundStyle(.secondary)
                
                HStack(spacing: 20) {
                    // 水平旋转（偏杆）
                    VStack {
                        Text("偏杆")
                            .font(.caption2)
                        Slider(value: $spinHorizontal, in: -1.0...1.0)
                            .frame(width: 120)
                    }
                    
                    // 垂直旋转（高低杆）
                    VStack {
                        Text("高低杆")
                            .font(.caption2)
                        Slider(value: $spinVertical, in: -1.0...1.0)
                            .frame(width: 120)
                    }
                }
            }
            
            // 快捷旋转按钮
            HStack(spacing: 10) {
                Button("高杆") {
                    spinVertical = 1.0
                    spinHorizontal = 0.0
                }
                .buttonStyle(.bordered)
                .font(.caption)
                
                Button("低杆") {
                    spinVertical = -1.0
                    spinHorizontal = 0.0
                }
                .buttonStyle(.bordered)
                .font(.caption)
                
                Button("左偏") {
                    spinHorizontal = -1.0
                    spinVertical = 0.0
                }
                .buttonStyle(.bordered)
                .font(.caption)
                
                Button("右偏") {
                    spinHorizontal = 1.0
                    spinVertical = 0.0
                }
                .buttonStyle(.bordered)
                .font(.caption)
                
                Button("无旋转") {
                    spinHorizontal = 0.0
                    spinVertical = 0.0
                }
                .buttonStyle(.bordered)
                .font(.caption)
            }
            
            // 击球按钮
            Button(action: shoot) {
                HStack {
                    Image(systemName: "play.fill")
                    Text("击球")
                }
                .frame(maxWidth: .infinity)
                .padding()
                .background(Color.green)
                .foregroundColor(.white)
                .cornerRadius(10)
            }
            
            // 辅助功能开关
            HStack {
                Toggle("瞄准线", isOn: Binding(
                    get: { scene?.aimingSystem.showAimLine ?? true },
                    set: { scene?.aimingSystem.showAimLine = $0 }
                ))
                .font(.caption)
                
                Toggle("假想球", isOn: Binding(
                    get: { scene?.aimingSystem.showGhostBall ?? true },
                    set: { scene?.aimingSystem.showGhostBall = $0 }
                ))
                .font(.caption)
                
                Toggle("轨迹", isOn: Binding(
                    get: { scene?.aimingSystem.showTrajectory ?? false },
                    set: { scene?.aimingSystem.showTrajectory = $0 }
                ))
                .font(.caption)
            }
        }
        .padding()
        .background(Color(.systemBackground).opacity(0.9))
        .cornerRadius(15)
    }
    
    private func shoot() {
        guard let scene = scene else { return }
        
        let force = scene.aimingSystem.calculateShotVector()
        let spin = SpinType.custom(horizontal: spinHorizontal, vertical: spinVertical)
        
        scene.physicsEngine.shootBall(force: force, spin: spin)
        scene.aimingSystem.hide()
    }
}
```

**验收标准**:
- [ ] 瞄准控制UI已创建
- [ ] 力度控制正常
- [ ] 旋转控制正常
- [ ] 击球功能正常

---

## 五、实现手势控制

### 5.1 添加手势识别

在 `BilliardSceneView.swift` 中添加：

```swift
func makeUIView(context: Context) -> SCNView {
    let sceneView = SCNView()
    
    // ... 现有配置 ...
    
    // 添加手势识别
    let panGesture = UIPanGestureRecognizer(
        target: context.coordinator,
        action: #selector(Coordinator.handlePan(_:))
    )
    sceneView.addGestureRecognizer(panGesture)
    
    let tapGesture = UITapGestureRecognizer(
        target: context.coordinator,
        action: #selector(Coordinator.handleTap(_:))
    )
    sceneView.addGestureRecognizer(tapGesture)
    
    return sceneView
}

class Coordinator: NSObject, SCNSceneRendererDelegate {
    var parent: BilliardSceneView
    var lastUpdateTime: TimeInterval = 0
    
    init(_ parent: BilliardSceneView) {
        self.parent = parent
    }
    
    @objc func handlePan(_ gesture: UIPanGestureRecognizer) {
        guard let sceneView = gesture.view as? SCNView else { return }
        guard let scene = parent.scene else { return }
        
        let translation = gesture.translation(in: sceneView)
        
        // 调整瞄准方向
        let sensitivity: Float = 0.01
        let deltaX = Float(translation.x) * sensitivity
        let deltaZ = Float(translation.y) * sensitivity
        
        var direction = scene.aimingSystem.aimDirection
        direction.x += deltaX
        direction.z += deltaZ
        
        // 归一化
        let length = sqrt(direction.x * direction.x + direction.z * direction.z)
        direction.x /= length
        direction.z /= length
        
        scene.aimingSystem.aimDirection = direction
        
        gesture.setTranslation(.zero, in: sceneView)
    }
    
    @objc func handleTap(_ gesture: UITapGestureRecognizer) {
        guard let sceneView = gesture.view as? SCNView else { return }
        guard let scene = parent.scene else { return }
        
        let location = gesture.location(in: sceneView)
        let hitResults = sceneView.hitTest(location, options: [:])
        
        // 检查是否点击了球
        for result in hitResults {
            if let ball = result.node as? BallNode, ball != scene.cueBall {
                scene.setTargetBall(ball)
                HapticManager.shared.selection()
                break
            }
        }
    }
    
    func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) {
        let deltaTime = lastUpdateTime == 0 ? 0 : time - lastUpdateTime
        lastUpdateTime = time
        
        if let scene = parent.scene {
            scene.update(deltaTime: deltaTime)
        }
    }
}
```

**验收标准**:
- [ ] 手势识别已添加
- [ ] 可以通过拖动调整瞄准方向
- [ ] 可以点击选择目标球
- [ ] 手势响应流畅

---

## 六、优化瞄准精度

### 6.1 添加分离角计算

在 `AimingSystem.swift` 中添加：

```swift
// MARK: - Advanced Calculations

func calculateSeparationAngle(cueBall: BallNode, targetBall: BallNode) -> Float {
    let cueBallPos = cueBall.position
    let targetBallPos = targetBall.position
    
    // 计算碰撞角度
    let direction = SCNVector3(
        x: targetBallPos.x - cueBallPos.x,
        y: 0,
        z: targetBallPos.z - cueBallPos.z
    )
    
    let distance = sqrt(direction.x * direction.x + direction.z * direction.z)
    
    // 计算分离角（简化版本）
    // 实际应用中需要考虑更多因素
    let separationAngle = asin(Float(BallNode.ballRadius * 2) / distance)
    
    return separationAngle
}

func calculateCutAngle(cueBall: BallNode, targetBall: BallNode, pocket: SCNVector3) -> Float {
    let targetBallPos = targetBall.position
    
    // 计算目标球到球袋的方向
    let toPocket = SCNVector3(
        x: pocket.x - targetBallPos.x,
        y: 0,
        z: pocket.z - targetBallPos.z
    )
    
    // 计算切球角度
    let angle = atan2(toPocket.x, toPocket.z)
    
    return angle
}

func predictBallPath(ball: BallNode, velocity: SCNVector3, steps: Int = 100) -> [SCNVector3] {
    var path: [SCNVector3] = []
    var currentPos = ball.position
    var currentVel = velocity
    
    let timeStep: Float = 0.016 // 60fps
    let friction: Float = 0.2
    
    for _ in 0..<steps {
        // 应用摩擦
        let speed = sqrt(currentVel.x * currentVel.x + currentVel.z * currentVel.z)
        if speed < 0.01 {
            break
        }
        
        let deceleration = friction * 9.8 * timeStep
        let newSpeed = max(0, speed - deceleration)
        
        currentVel.x = (currentVel.x / speed) * newSpeed
        currentVel.z = (currentVel.z / speed) * newSpeed
        
        // 更新位置
        currentPos.x += currentVel.x * timeStep
        currentPos.z += currentVel.z * timeStep
        
        path.append(currentPos)
        
        // 检查边界碰撞
        if abs(currentPos.x) > Float(TableNode.tableWidth / 2) ||
           abs(currentPos.z) > Float(TableNode.tableLength / 2) {
            break
        }
    }
    
    return path
}
```

**验收标准**:
- [ ] 分离角计算正确
- [ ] 切球角度计算正确
- [ ] 球路预测功能实现

---

## 七、测试瞄准系统

### 7.1 更新测试视图

更新 `SceneTestView.swift`：

```swift
struct SceneTestView: View {
    @State private var scene: BilliardScene?
    
    var body: some View {
        ZStack {
            BilliardSceneView(scene: $scene)
                .ignoresSafeArea()
            
            VStack {
                Spacer()
                
                if scene != nil {
                    AimingControlView(scene: $scene)
                        .padding()
                }
            }
        }
        .onAppear {
            setupTestScene()
        }
    }
    
    private func setupTestScene() {
        guard let scene = scene else { return }
        
        // 添加几个测试球
        scene.addTargetBall(at: SCNVector3(x: 0, y: 0.03, z: 0), number: 1)
        scene.addTargetBall(at: SCNVector3(x: 0.2, y: 0.03, z: -0.5), number: 2)
        scene.addTargetBall(at: SCNVector3(x: -0.2, y: 0.03, z: -0.5), number: 3)
    }
}
```

**验收标准**:
- [ ] 测试场景正确设置
- [ ] 瞄准控制UI正常显示
- [ ] 所有功能正常工作

---

## 八、常见问题和解决方案

### 问题1：瞄准线位置不准确

**解决方案**:
```swift
// 确保瞄准线的Y坐标与球的Y坐标一致
aimLine.position = SCNVector3(
    x: position.x + direction.x * lineLength / 2,
    y: Float(BallNode.ballRadius), // 使用球的半径作为高度
    z: position.z + direction.z * lineLength / 2
)
```

### 问题2：假想球位置偏移

**解决方案**:
```swift
// 精确计算球心距离
let ballDiameter = Float(BallNode.ballRadius * 2)
ghostBall.position = SCNVector3(
    x: targetBallPos.x - normalizedDir.x * ballDiameter,
    y: targetBallPos.y,
    z: targetBallPos.z - normalizedDir.z * ballDiameter
)
```

### 问题3：手势控制不灵敏

**解决方案**:
```swift
// 调整灵敏度参数
let sensitivity: Float = 0.005 // 降低此值使控制更精细
```

---

## 九、提交代码

```bash
git add .
git commit -m "feat: Implement aiming system

- Created AimingSystem with aim line and ghost ball
- Implemented DiamondSystem for advanced aiming
- Added AimingControlView for UI controls
- Implemented gesture controls for aiming
- Added separation angle and cut angle calculations
- Added ball path prediction
"
```

---

## 十、最终验收清单

- [ ] AimingSystem完整实现
- [ ] 瞄准线显示正确
- [ ] 假想球位置准确
- [ ] 轨迹线显示正常
- [ ] DiamondSystem实现
- [ ] 手势控制流畅
- [ ] UI控制完善
- [ ] 高级计算功能实现
- [ ] 测试通过
- [ ] 代码已提交

---

## 下一步

完成本步骤后，继续进行：
- **步骤5**: 相机系统实现
- **步骤6**: 课程系统实现

---

**预计完成时间**: 3-4天
**实际完成时间**: ___________
**遇到的问题**: ___________
**解决方案**: ___________
